/**
 * NOTE: This class is auto generated by the swagger code generator program (3.0.22).
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */
package com.b4nkd.experian.txnservices.api;

import com.b4nkd.experian.txnservices.model.Account;
import com.b4nkd.experian.txnservices.model.ArrayOfCustomerAccounts;
import java.math.BigDecimal;
import com.b4nkd.experian.txnservices.model.CallbackUrl;
import com.b4nkd.experian.txnservices.model.CreateCustomerResponse;
import com.b4nkd.experian.txnservices.model.Customer;
import com.b4nkd.experian.txnservices.model.CustomerAccount;
import com.b4nkd.experian.txnservices.model.CustomerRequest;
import com.b4nkd.experian.txnservices.model.Customers;
import com.b4nkd.experian.txnservices.model.ErrorResponse;
import com.b4nkd.experian.txnservices.model.Institution;
import com.b4nkd.experian.txnservices.model.MfaChallenge;
import com.b4nkd.experian.txnservices.model.MfaChallenges;
import com.b4nkd.experian.txnservices.model.ModifyPartnerRequest;
import org.springframework.core.io.Resource;
import com.b4nkd.experian.txnservices.model.StoreCustomerPayStatementRequest;
import com.b4nkd.experian.txnservices.model.StoreCustomerPayStatementResponse;
import com.b4nkd.experian.txnservices.model.SubscriptionList;
import com.b4nkd.experian.txnservices.model.Transaction;
import com.b4nkd.experian.txnservices.model.TransactionResponseForTesting;
import com.b4nkd.experian.txnservices.model.UserNameRequest;
import io.swagger.annotations.*;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.bind.annotation.CookieValue;

import javax.validation.Valid;
import javax.validation.constraints.*;
import java.util.List;
import java.util.Map;
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.SpringCodegen", date = "2020-11-15T11:00:50.772965300Z[Europe/London]")
@Api(value = "aggregation", description = "the aggregation API")
public interface AggregationApi {

    @ApiOperation(value = "Add Transaction for Testing Account", nickname = "addTransactionForTestingAccount", notes = "Inject a transaction into the transaction list for a testing account. This allows an app to trigger TxPUSH notifications for the account in order to test the appâ€™s TxPUSH Listener service. <br><br>This causes the platform to send one transaction event and one account event (showing that the account balance has changed). This service is only supported for testing accounts (accounts on institution 101732). ", response = TransactionResponseForTesting.class, authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 201, message = "Request Created", response = TransactionResponseForTesting.class),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v1/customers/{customerID}/accounts/{accountID}/transactions",
        produces = { "*/*" }, 
        consumes = { "*/*" },
        method = RequestMethod.POST)
    ResponseEntity<TransactionResponseForTesting> addTransactionForTestingAccount(@ApiParam(value = "Input request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "The Finicity ID of the customer who owns the account",required=true) @PathVariable("customerID") Integer customerID
,@ApiParam(value = "The Finicity ID of the account whose events will be sent to the TxPUSH Listener",required=true) @PathVariable("accountID") Integer accountID
,@ApiParam(value = "Transaction record" ,required=true )  @Valid @RequestBody Transaction body
,@ApiParam(value = "Input Transactional Services subcode assigned" , defaultValue="0.0") @RequestHeader(value="subcode", required=false) BigDecimal subcode
);


    @ApiOperation(value = "Create Active Customer", nickname = "createActiveCustomer", notes = "Enroll an active customer (the actual owner of one or more real-world accounts). The customer's account transactions will be refreshed every night.", response = CreateCustomerResponse.class, authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 201, message = "Customer Created", response = CreateCustomerResponse.class),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v1/customers/active",
        produces = { "*/*" }, 
        consumes = { "*/*" },
        method = RequestMethod.POST)
    ResponseEntity<CreateCustomerResponse> createActiveCustomer(@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "Input request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "" ,required=true )  @Valid @RequestBody UserNameRequest body
,@ApiParam(value = "Input Transactional Services subcode assigned" , defaultValue="0.0") @RequestHeader(value="subcode", required=false) BigDecimal subcode
);


    @ApiOperation(value = "Delete Customer", nickname = "deleteCustomer", notes = "\"Completely remove a customer from the system. This will remove the customer and all associated accounts, transactions, and aggregation support tickets. <br><br>Use this service carefully! It will not pause for confirmation before performing the operation!\" ", authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 204, message = "The resource was deleted successfully."),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v1/customers/{customerID}",
        produces = { "application/json", "application/xml" }, 
        method = RequestMethod.DELETE)
    ResponseEntity<Void> deleteCustomer(@ApiParam(value = "ID of Customer to modify",required=true) @PathVariable("customerID") Integer customerID
,@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "Input request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "Input Transactional Services subcode assigned" , defaultValue="0.0") @RequestHeader(value="subcode", required=false) BigDecimal subcode
);


    @ApiOperation(value = "Delete Customer Account", nickname = "deleteCustomerAccount", notes = "Remove the specified account from the Finicity system.", authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 204, message = "Customer Deleted"),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v1/customers/{customerID}/accounts/{accountID}",
        produces = { "application/json", "application/xml" }, 
        method = RequestMethod.DELETE)
    ResponseEntity<Void> deleteCustomerAccount(@ApiParam(value = "Input request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "The ID of the customer whose account are to be deleted",required=true) @PathVariable("customerID") Integer customerID
,@ApiParam(value = "The Finicity ID of the account to be deleted",required=true) @PathVariable("accountID") Integer accountID
,@ApiParam(value = "Input Transactional Services subcode assigned" , defaultValue="0.0") @RequestHeader(value="subcode", required=false) BigDecimal subcode
);


    @ApiOperation(value = "Delete TxPUSH Subscription", nickname = "deleteTxPUSHSubscription", notes = "Delete a specific subscription for a class of events (account or transaction events) related to an account. No more notifications will be sent for these events.", authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 204, message = "The resource was deleted successfully."),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v1/customers/{customerID}/subscriptions/{subscriptionId}",
        produces = { "*/*" }, 
        method = RequestMethod.DELETE)
    ResponseEntity<Void> deleteTxPUSHSubscription(@ApiParam(value = "ID of Customer to fetch",required=true) @PathVariable("customerID") Integer customerID
,@ApiParam(value = "ID of Subscription to fetch",required=true) @PathVariable("subscriptionId") Integer subscriptionId
,@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "Input request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "Input Transactional Services subcode assigned" , defaultValue="0.0") @RequestHeader(value="subcode", required=false) BigDecimal subcode
);


    @ApiOperation(value = "Disable TxPUSH Notifications", nickname = "disableTxPUSHNotifications", notes = "Disable all TxPUSH notifications for the indicated account. No more notifications will be sent for account or transaction events.", authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 204, message = "The resource was deleted successfully."),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v1/customers/{customerID}/accounts/{accountID}/txpush",
        produces = { "*/*" }, 
        method = RequestMethod.DELETE)
    ResponseEntity<Void> disableTxPUSHNotifications(@ApiParam(value = "ID of Customer to fetch",required=true) @PathVariable("customerID") Integer customerID
,@ApiParam(value = "ID of Customer account to fetch",required=true) @PathVariable("accountID") Integer accountID
,@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "Input request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "Input Transactional Services subcode assigned" , defaultValue="0.0") @RequestHeader(value="subcode", required=false) BigDecimal subcode
);


    @ApiOperation(value = "Enable TxPUSH Notifications", nickname = "enableTxPUSHNotifications", notes = "Register a client appâ€™s TxPUSH Listener to receive TxPUSH notifications related to the given account. ", response = SubscriptionList.class, authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 201, message = "Request Created", response = SubscriptionList.class),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v1/customers/{customerID}/accounts/{accountID}/txpush",
        produces = { "*/*" }, 
        consumes = { "*/*" },
        method = RequestMethod.POST)
    ResponseEntity<SubscriptionList> enableTxPUSHNotifications(@ApiParam(value = "Input request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "The Finicity ID of the customer who owns the account",required=true) @PathVariable("customerID") Integer customerID
,@ApiParam(value = "The Finicity ID of the account whose events will be sent to the TxPUSH Listener",required=true) @PathVariable("accountID") Integer accountID
,@ApiParam(value = "The TxPUSH Listener URL to receive TxPUSH notifications" ,required=true )  @Valid @RequestBody CallbackUrl body
,@ApiParam(value = "Input Transactional Services subcode assigned" , defaultValue="0.0") @RequestHeader(value="subcode", required=false) BigDecimal subcode
);


    @ApiOperation(value = "Get Bank Statements", nickname = "getBankStatements", notes = "Connect to the account's financial institution and download the most recent monthly statement for the account, in PDF format. This is an interactive refresh, so MFA challenges may be required. The index parameter allows an app to request statements earlier than the most recent one. <br/><br/>The default is 1, meaning the most recent statement. Another value such as 3 would mean to count back and retrieve the third most recent statement. For example, if a request is made in July, the most recent statement (index 1) would probably be for June, and the third most recent statement (index 3) would be for April.<br><br>HTTP status of 200 means the statement was retrieved successfully, and the body of the response contains the bytes of the PDF document.<br><br>HTTP status of 203 means the response contains an MFA challenge in XML or JSON format.  ", response = Resource.class, authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Success", response = Resource.class),
        @ApiResponse(code = 203, message = "Account Details (MFA Challenge)", response = MfaChallenges.class),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v1/customers/{customerID}/accounts/{accountID}/statement",
        produces = { "*/*" }, 
        method = RequestMethod.GET)
    ResponseEntity<Resource> getBankStatements(@ApiParam(value = "ID of Customer to fetch",required=true) @PathVariable("customerID") Integer customerID
,@ApiParam(value = "ID of Customer account to fetch",required=true) @PathVariable("accountID") Integer accountID
,@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "Input request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "Input Transactional Services subcode assigned" , defaultValue="0.0") @RequestHeader(value="subcode", required=false) BigDecimal subcode
,@ApiParam(value = "Index of statement to retrieve (default is 1, maximum is 6)", defaultValue = "1") @Valid @RequestParam(value = "index", required = false, defaultValue="1") Integer index
);


    @ApiOperation(value = "Get Bank Statements wMFA", nickname = "getBankStatementsWMFA", notes = "Send MFA answers for an earlier challenge while getting an account statement. <br><br>This service is invoked only if a previous call to Get Customer Account Statement or Get Customer Account Statement (with MFA Answers) has returned HTTP 203. The response from that previous call is referred to as \"the previous response\" below. <br><br>HTTP status of 200 means the statement was retrieved successfully, and the body of the response contains the bytes of the PDF document. <br><br>HTTP status of 203 means the response contains an MFA challenge in XML or JSON format.  ", response = Resource.class, authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Success", response = Resource.class),
        @ApiResponse(code = 203, message = "Account Details (MFA Challenge)", response = MfaChallenges.class),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v1/customers/{customerID}/accounts/{accountID}/statement/mfa",
        produces = { "*/*" }, 
        consumes = { "*/*" },
        method = RequestMethod.POST)
    ResponseEntity<Resource> getBankStatementsWMFA(@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "Input request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "Session identifier.Copied directly from the previous response (the value will be different for each HTTP 203 response received)" ,required=true, defaultValue="MFA_SESSION") @RequestHeader(value="MFA-Session", required=true) String mfASession
,@ApiParam(value = "ID of Customer to fetch",required=true) @PathVariable("customerID") Integer customerID
,@ApiParam(value = "ID of Customer account to fetch",required=true) @PathVariable("accountID") Integer accountID
,@ApiParam(value = "MFA Challenges Segment" ,required=true )  @Valid @RequestBody MfaChallenge body
,@ApiParam(value = "Input Transactional Services subcode assigned" , defaultValue="0.0") @RequestHeader(value="subcode", required=false) BigDecimal subcode
);


    @ApiOperation(value = "Get Customer", nickname = "getCustomer", notes = "Return account details for the specified customer. Must know customer ID to search.", response = Customer.class, authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "OK", response = Customer.class),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v1/customers/{customerID}",
        produces = { "*/*" }, 
        method = RequestMethod.GET)
    ResponseEntity<Customer> getCustomer(@ApiParam(value = "ID of Customer to fetch",required=true) @PathVariable("customerID") String customerID
,@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "Input request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "Input Transactional Services subcode assigned" , defaultValue="0.0") @RequestHeader(value="subcode", required=false) BigDecimal subcode
);


    @ApiOperation(value = "Get Customer Account", nickname = "getCustomerAccount", notes = "Get details for one account owned by the specified customer. Need the Account ID", response = CustomerAccount.class, authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Success", response = CustomerAccount.class),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v1/customers/{customerID}/accounts/{accountID}",
        produces = { "*/*" }, 
        method = RequestMethod.GET)
    ResponseEntity<CustomerAccount> getCustomerAccount(@ApiParam(value = "ID of Customer to fetch",required=true) @PathVariable("customerID") String customerID
,@ApiParam(value = "ID of Customer account to fetch",required=true) @PathVariable("accountID") Integer accountID
,@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "Input request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "Input Transactional Services subcode assigned" , defaultValue="0.0") @RequestHeader(value="subcode", required=false) BigDecimal subcode
);


    @ApiOperation(value = "Get Customer Account Details", nickname = "getCustomerAccountDetails", notes = "Connect to the account's financial institution and retrieve the ACH data for the indicated account. This may be an interactive refresh, so MFA challenges may be required. <br><br>HTTP status of 200 means both realAccountNumber and routingNumber were returned successfully in the body of the response. <br><br>HTTP status of 203 means the response contains an MFA challenge in XML or JSON format. ", response = Account.class, authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Account Details", response = Account.class),
        @ApiResponse(code = 203, message = "Account Details (MFA Challenge)", response = MfaChallenge.class),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v1/customers/{customerID}/accounts/{accountID}/details",
        produces = { "*/*" }, 
        method = RequestMethod.GET)
    ResponseEntity<Account> getCustomerAccountDetails(@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "Input request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "The ID of the customer who owns the account",required=true) @PathVariable("customerID") Integer customerID
,@ApiParam(value = "The Finicity ID of the account",required=true) @PathVariable("accountID") Integer accountID
,@ApiParam(value = "Input Transactional Services subcode assigned" , defaultValue="0.0") @RequestHeader(value="subcode", required=false) BigDecimal subcode
);


    @ApiOperation(value = "Get Customer Account Details wMFA", nickname = "getCustomerAccountDetailsWMFA", notes = "Send MFA answers for an earlier challenge while getting account details. <br><br>HTTP status of 200 means both realAccountNumber and routingNumber were returned successfully in the body of the response. <br><br>HTTP status of 203 means the response contains an MFA challenge in XML or JSON format. ", response = Account.class, authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Account Details", response = Account.class),
        @ApiResponse(code = 203, message = "Account Details (MFA Challenge)", response = MfaChallenge.class),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v1/customers/{customerId}/accounts/{accountId}/details/mfa",
        produces = { "*/*" }, 
        consumes = { "*/*" },
        method = RequestMethod.POST)
    ResponseEntity<Account> getCustomerAccountDetailsWMFA(@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "Input request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "Session identifier.Copied directly from the previous response (the value will be different for each HTTP 203 response received)" ,required=true, defaultValue="MFA_SESSION") @RequestHeader(value="MFA-Session", required=true) String mfASession
,@ApiParam(value = "The ID of the customer who owns the account",required=true) @PathVariable("customerId") Integer customerId
,@ApiParam(value = "The Finicity ID of the account",required=true) @PathVariable("accountId") Integer accountId
,@ApiParam(value = "MFA Challenges Segment" ,required=true )  @Valid @RequestBody MfaChallenges body
,@ApiParam(value = "Input Transactional Services subcode assigned" , defaultValue="0.0") @RequestHeader(value="subcode", required=false) BigDecimal subcode
);


    @ApiOperation(value = "Get Customer Accounts", nickname = "getCustomerAccounts", notes = "Get details for one account owned by the specified customer. Need the Account ID", response = ArrayOfCustomerAccounts.class, authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Success", response = ArrayOfCustomerAccounts.class),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v1/customers/{customerID}/accounts",
        produces = { "*/*" }, 
        method = RequestMethod.GET)
    ResponseEntity<ArrayOfCustomerAccounts> getCustomerAccounts(@ApiParam(value = "ID of Customer to fetch",required=true) @PathVariable("customerID") String customerID
,@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "Input request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "Input Transactional Services subcode assigned" , defaultValue="0.0") @RequestHeader(value="subcode", required=false) BigDecimal subcode
);


    @ApiOperation(value = "Get Customer Accounts by Institution", nickname = "getCustomerAccountsByInstitution", notes = "Get details for all active accounts owned by the specified customer at the specified institution", response = ArrayOfCustomerAccounts.class, authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Success", response = ArrayOfCustomerAccounts.class),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v1/customers/{customerID}/institutions/{institutionID}/accounts",
        produces = { "*/*" }, 
        method = RequestMethod.GET)
    ResponseEntity<ArrayOfCustomerAccounts> getCustomerAccountsByInstitution(@ApiParam(value = "ID of Customer to fetch",required=true) @PathVariable("customerID") Integer customerID
,@ApiParam(value = "ID of institution to fetch",required=true) @PathVariable("institutionID") Integer institutionID
,@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "Input request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "Input Transactional Services subcode assigned" , defaultValue="0.0") @RequestHeader(value="subcode", required=false) BigDecimal subcode
);


    @ApiOperation(value = "Get Customers", nickname = "getCustomers", notes = "Find all customers enrolled by the current partner, where the search text is found in the customer's username or any combination of firstName and lastName fields. <br><br>If no search text is provided, return all customers. Valid values for type are testing, active. Customer must already exist in database. ", response = Customers.class, authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Success", response = Customers.class),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v1/customers",
        produces = { "*/*" }, 
        method = RequestMethod.GET)
    ResponseEntity<Customers> getCustomers(@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "Input request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "Input Transactional Services subcode assigned" , defaultValue="0.0") @RequestHeader(value="subcode", required=false) BigDecimal subcode
,@ApiParam(value = "Text to match or leave empty to return all customers. Request URLs must be URL-encoded. In practice this means that spaces in URL query values must be replaced with â€˜+â€™ and the @ symbol must be replaced with '%40'.", defaultValue = "New+York+City") @Valid @RequestParam(value = "search", required = false, defaultValue="New+York+City") String search
,@ApiParam(value = "Username for exact match. (Will return 0 or 1 records.)", defaultValue = "johnDoeUser") @Valid @RequestParam(value = "username", required = false, defaultValue="johnDoeUser") String username
,@ApiParam(value = "Starting index for this page of results", defaultValue = "1.0") @Valid @RequestParam(value = "start", required = false, defaultValue="1.0") BigDecimal start
,@ApiParam(value = "Maximum number of entries for this page of results", defaultValue = "25.0") @Valid @RequestParam(value = "limit", required = false, defaultValue="25.0") BigDecimal limit
,@ApiParam(value = "One of the values testing or active to return only customers of that type, or leave empty to return all customers.", defaultValue = "testing") @Valid @RequestParam(value = "type", required = false, defaultValue="testing") String type
);


    @ApiOperation(value = "Get Institution", nickname = "getInstitution", notes = "Get details for the specified institution.", response = Institution.class, authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Success", response = Institution.class),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v1/institutions/{institutionID}",
        produces = { "*/*" }, 
        method = RequestMethod.GET)
    ResponseEntity<Institution> getInstitution(@ApiParam(value = "ID of institution to fetch",required=true) @PathVariable("institutionID") Integer institutionID
,@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "Input request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "Input Transactional Services subcode assigned" , defaultValue="0.0") @RequestHeader(value="subcode", required=false) BigDecimal subcode
);


    @ApiOperation(value = "Modify Customer", nickname = "modifyCustomer", notes = "Modify the details for an enrolled customer. You must specify either firstName/lastName or both in the request.   ", authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 204, message = "The resource was modified successfully."),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v1/customers/{customerID}",
        produces = { "*/*" }, 
        consumes = { "*/*" },
        method = RequestMethod.PUT)
    ResponseEntity<Void> modifyCustomer(@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "Input Request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "ID of Customer to fetch",required=true) @PathVariable("customerID") String customerID
,@ApiParam(value = "" ,required=true )  @Valid @RequestBody CustomerRequest body
,@ApiParam(value = "Input Transactional Services subcode assigned" , defaultValue="0.0") @RequestHeader(value="subcode", required=false) BigDecimal subcode
);


    @ApiOperation(value = "Modify Partner Secret", nickname = "modifyPartnerSecret", notes = "Change the partner secret that is used to authenticate this partner. The secret does not expire, but can be changed by calling Modify Partner Secret. ", authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 204, message = "The resource was modified successfully."),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v2/partners/authentication",
        produces = { "*/*" }, 
        consumes = { "*/*" },
        method = RequestMethod.PUT)
    ResponseEntity<Void> modifyPartnerSecret(@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "Input Request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "" ,required=true )  @Valid @RequestBody ModifyPartnerRequest body
,@ApiParam(value = "Input Transactional Services subcode assigned" , defaultValue="0.0") @RequestHeader(value="subcode", required=false) BigDecimal subcode
);


    @ApiOperation(value = "Store Customer Pay Statement", nickname = "storeCustomerPayStatement", notes = "Srore Pay Statements for the given consumer. This service accepts pay statements to be stored. Finicity will extract relevant data from each of the pay statements.A report will be built with the data extracted from the pay statements.  ", response = StoreCustomerPayStatementResponse.class, authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 202, message = "Request Accepted", response = StoreCustomerPayStatementResponse.class),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v1/customers/{customerID}/payStatements",
        produces = { "*/*" }, 
        consumes = { "*/*" },
        method = RequestMethod.POST)
    ResponseEntity<StoreCustomerPayStatementResponse> storeCustomerPayStatement(@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "Input request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "Input Transactional Services subcode assigned" ,required=true, defaultValue="0.0") @RequestHeader(value="subcode", required=true) BigDecimal subcode
,@ApiParam(value = "ID of the customer",required=true) @PathVariable("customerID") Integer customerID
,@ApiParam(value = "The request with Pay statements." ,required=true )  @Valid @RequestBody StoreCustomerPayStatementRequest body
);


    @ApiOperation(value = "Create Testing Customer", nickname = "testingCustomer", notes = "Enroll a testing customer. A testing customer may only register accounts with FinBank.", response = CreateCustomerResponse.class, authorizations = {
        @Authorization(value = "OauthSecurity", scopes = { 
            @AuthorizationScope(scope = "admin", description = "admin scope"),
            @AuthorizationScope(scope = "user", description = "user scope")
            })    }, tags={ "Consumer", })
    @ApiResponses(value = { 
        @ApiResponse(code = 201, message = "Customer Created", response = CreateCustomerResponse.class),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/aggregation/v1/customers/testing",
        produces = { "*/*" }, 
        consumes = { "*/*" },
        method = RequestMethod.POST)
    ResponseEntity<CreateCustomerResponse> testingCustomer(@ApiParam(value = "Type of format to Accept" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Accept", required=true) String accept
,@ApiParam(value = "Input request format" ,required=true, allowableValues="application/json, application/xml", defaultValue="application/json") @RequestHeader(value="Content-Type", required=true) String contentType
,@ApiParam(value = "" ,required=true )  @Valid @RequestBody UserNameRequest body
,@ApiParam(value = "Input Transactional Services subcode assigned" , defaultValue="0.0") @RequestHeader(value="subcode", required=false) BigDecimal subcode
);

}

